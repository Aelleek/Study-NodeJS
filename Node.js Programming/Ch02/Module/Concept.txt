p68.

● 노드에서 모듈 사용하기.

  - 메인 파일의 코드 중에서 독립적인 기능은 별도 파일로 분리할 수 있으며, 메인 파일에서는 전체적인 실행 순서나 흐름만을 제어한다.
   이렇게 분리된 파일을 노드에서는 모듈이라고 부른다.

   -> C언어에서는 각 기능별로 함수를 분리해서 작성하는 것 / 자바에서는 각 기능에 맞는 클래스로 분리하는 것과 같은 개념.

   각각의 기능을 분리시킬 때는 단순히 별도의 파일에 코드를 나누어 놓는것이 끝이 아니라 분리되어 있는 모듈 파일을 불러와서 사용할 수 있는 방법도 만들어야 한다.
   노드는 CommonJs의 표준 스팩을 따라 모듈을 사용할 수 있게 한다.
   이 과정에서 exports 전역 객체를 사용한다.

  - 브라우저 상에서 동작하는 JavaScript는 html의 스크립트 태그에 여러 개의 JavaScript 파일을 로드하는 경우 하나의 파일로 merge되면 동일한 Scope를 갖게된다.
    Javascript는 웹페이지의 보조적인 기능을 수행하기 위한 용도로 만들어진 태생적인 한계로 여러가지 부족한 부분이 있는데 그 중에 하나가 모듈 기능이 없는 것이다. JavaScript를 프론트엔드에 국한하지 않고 범용적으로 사용하고자 하면서 모듈 기능은 반드시 해결해야하는 핵심과제가 되었다.

    -> c언어나 Java 언어처럼 각 파일이 각각의 Scope를 갖는것과는 달리 JavaScript는 여러개의 파일이 하나의 파일로 merge되는 형태라서 파일을 나눠서 작성 하더라도 같이 로드되는 javaScript 파일들의 Scope가 동일해지는 문제가 생기기 때문에 모듈 기능이 필요해진것이다. (?)

    Node.js는 모듈 단위로 각 기능을 분할할 수 있고 모듈은 파일과 1:1 대응 관계를 가지며 하나의 모듈은 자신만의 독립적인 Scope를 가지게 된다. 그래서
    프론트엔드의 JavaScript와는 달리 전역변수의 중복문제가 발생하지 않는다.

    모듈은 module.exports 또는 exports 객체를 통해 정의하고 외부로 공개한다. 그리고 공개된 모듈은 require() 메소드를 사용하여 import 한다.

    ◆ https://poiemaweb.com/nodejs-module


○ exports 객체.

  - 모듈은 독립적인 파일 스코프를 갖기 때문에 모듈 안에 선언한 모든 것들은 기본적으로 해당 모듈 내부에서만 참조가 가능하다.
    만약 모듈 안에 선언한 항목을 외부에 공개하여 다른 모듈들이 사용할 수 있게 하고 싶다면 exports 객체를 사용해야 한다.

    모듈을 파일로 작성하고 외부에 공개할 대상을 exports 객체의 프로퍼티 또는 메소드로 정의한다. 그리고 모듈을 전역 함수 require()를 이용하여 추출한다.

  - exports 객체에는 값을 할당할 수 없고 공개할 대상을 exports 객체에 프로퍼티 또는 메소드로 추가한다.


○ module.exports.

  - exports 객체는 프로퍼티 또는 메소드를 여러 개 정의할 수 있다. 하지만 module.exports에는 하나의 값(원시 타입, 함수, 객체)을 할당할 수 있다.

  - module.exports 객체에 하나의 값만을 할당한다.


○ require() 메소드.

  - 작성하거나 공개된 모듈을 require() 메소드를 사용하여 import 한다.
    작성한 모듈(내부모듈)같은 경우에는 상대Path를 파라미터로 작성하고, 내장모듈이나 외장모듈의 경우에는 모듈의 이름을 파라미터로 작성한다.

  - 파라미터로는 모듈의 상대경로나 모듈명뿐만 아니라 디렉토리명도 작성할 수 있다.
    모듈을 명시하지 않고 require() 메소드를 호출하면 해당 디렉토리의 index.js를 로드한다.




● 모듈을 사용하는 3가지 방법.

  - 노드JS에서는 3종류의 모듈이 있다. 사용자가 정의한 메소드인 내부모듈, 노드JS 언어 자체에서 제공하는 메소드들인 내장모듈, 다른 사용자가 정의해놓은 메소드들인 외장모듈.
    모듈을 불러올 때는 require() 메소드를 사용하여 파라미터로 모듈의 이름이나, 모듈화 해 놓은 파일의 이름을 전달한다.
    require() 메소드는 파라미터로 받은 모듈의 객체를 반환한다.


○ 내부모듈(파일모듈)

  - 사용자가 정의한 모듈이다.

○ 내장모듈(코어모듈)

  - Node.JS 언어에서 기본적으로 제공하는 모듈이다.
    내장모듈에 대한 정보는 www.nodejs.org/api 에서 자세하게 확인할 수 있다.

    os 모듈 : 시스템 정보를 알려주는 모듈
    path 모듈 : 파일 패스를 다루는 모듈

○ 외장모듈(외부 패키지)














의문점

1. exports라는 전역객체를 이렇게 사용해도 되는건가?
   예를들면 c언어에서는 전역변수나 전역함수를 쓰게되는 경우 신중하게 써야한다고 배웠고, Java에서도 특별한 경우 관리를 위한 전역변수 전역메소드들을 사용했었다.

   그러니까 전역객체를 사용할수는 있어 근데 exports 객체 같은경우에는 사용하는 경우가 엄청 빈번하게 일어날텐데.. 이걸 꼭 전역객체로 만들었어야 하는건가? 아닌가
   어차피 파일 내부에서만 적용되는거니까? 단순히 exports는 어떤 파일을 불러 올건지에 대해서만 동작하는거고 그 기능들은 파일 내에서만 동작하니까?
   그럼 exports 객체가 불러올 파일들의 이름이 같다면? 그치 하나의 폴더안에 같은 이름의 파일이 존재하진 않을거고 
   만약 이름이 같지만 같은 폴더내의 파일이 아닌 다른 폴더의 파일을 가져오고 싶다면 절대경로를 입력해서 가져오면 되는거고?

   그 이유는?
   글로벌한 변수나 함수를 많이 사용하게 되면 기존의 변수나 함수와 충돌 날 수도 있다.
   특히 협업하는 경우에 여러명이 동일한 식별자를 사용하면 충돌이 날 수 있지 않나?
   좀 다른 개념인가.. 사실 exports 해올때 각각의 변수에 해당하는 파일을 할당하기 때문에 동일한 식별자의 충돌은 나지 않을거 같은데..
   처음에 의문이 떠올랐을때는 정확히 이 문제가 아니었던거 같은데

   모듈이라고 이름 붙여있기는 하지만 사소한 기능 하나부터 큰 라이브러리 개념의 기능까지 각각 파일로 분리해서 관리하는 당연한 개념이고
   분리되어있는 파일을 사용하기 위해서 exports 라는 객체를 사용하는건데..
   c에서는 include 같은 개념이고 자바에서는 import 같은 개념인데.....
   c나 java에서는 언어 자체에서 제공하는 api만 사용하기때문에 즉, 외장 모듈을 사용하지 않기때문에? exports같은 전역객체가 필요가 없었나?
   노드같은 경우에는 외장모듈을 가져다 쓰는 경우가 빈번하고 종류가 많고 그것이 강점이기 때문에 전역객체가 필요한거고?

   그럼 c나 java에서 전역변수나 객체를 사용하면 안되는 중요한 이유가 무엇이었지?

   c에서는 하나의 프로젝트에서 기능별로 cpp 파일을 나눴다고 하더라도, 같은 프로젝트는 같은 패키지로 인식 되기때문에 
   노드처럼 명시적으로 하나의 파일을 지정해서 변수에 할당하지 않아도 다른 파일의 전역변수에 접근이 가능했지
   그래서 작업하다가 의도하지 않게 전역변수에 접근할수도 있고, 실수로 전역변수 값을 변경할수도 있었어

   자바에서는 왜 전역객체를 사용하면 안됐지?
   기본적으로 객체지향 관점에서 클래스를 설계할때 impormation hiding은 기본이었어 아니 이거랑 상관없나?
   클래스의 정보를 감추는것과 아무곳에서나 접근할 수 있는건 개념이 좀 다른데?
   음 클래스 설계할때 기본적으로 각각의 역할이 정해져있는 클래스를 설계했었고, 그 역할에 따라 클래스간의 관계도가 나왔어
   그래서 우리 했던 설계 내에서는 전역 객체처럼 어느곳에서든 접근해서 사용해야하는 객체가 나올일이 없었지
   그리고 그게 객체지향 개념에 있어서 기본적이 클래스 설계 방법이었고
   그래서 배우기를 특정한 이유가 있는 객체나 변수가 아니라면 전역으로 설계하지 말라고 했지
   예를들면 어떤 객체의 숫자를 기록해야하는 변수라던가, singleton 패턴으로 만들어진 객체..
   DAO같은 경우에는 model쪽의 클래스들에서 같은 클래스 객체를 계속 반복 호출하기 때문에 싱글턴 패턴을 적용해서 하나의 객체만 만들고
   그 객체만 가져다 쓰겠다고 하는거고 그거는 계속 DAO 객체를 생성 소멸하는 과정을 없애서 효율적으로 만들기 위한 이유로 전역객체를 만든거고?



 2. 전역객체 exports 에 파일을 저장하는 형태인거잖아?
    그럼? exports 객체에는 계속 여러개의 파일의 정보가 담겨있는거고
    근데 동일한 식별자로 저장되어있으면 require() 메소드 호출할때 path를 정확히 입력해줘야 하는거고?
    불편하지 않아? 
    그리고 내부 모듈은 무조건 path를 지정해줘야 하는건가
    만약 그렇다면 내부모듈의 이름과 외장 모듈의 이름이 같은 경우에는
    내가 사용하고 싶은 모듈은 외장모듈인데? 내부모듈이 불려온다면?
    내부 모듈 같은 경우에는 상대패스를 정확히 입력해줘야 하기 때문에 내부 모듈과 외장 모듈이 겹치는 경우는 없다.

    그럼 만약에 외장 모듈의 이름이 같다면? 이건 다른 사용자들이 만든 모듈이라서 충분히 가능성 있는거 아니야?
    식별자 명명규칙이 따로 있을까?
    만든 사용자를 구분하기 위한 명명규칙이 존재한다면 모듈의 이름이 직관적이지 않을거 같은데?

    외장 모듈의 이름이 겹치는 경우가 있는지 확인해볼것.



    내부 모듈은 사용자 정의 함수 개념이고
    내장 모듈을 언어 자체에서 제공하는 라이브러리 개념이고
    외장 모듈은 다른 사용자들이 만든 사용자 정의 함수 개념이다?



(?) 모듈이라는 형태를 사용하게 된 이유는 무엇이지.
    자바스크립트가 여러 파일을 로드할때 하나의 파일로 merge되서 변수가 겹친다거나 하는 문제가 생기는건 이해했어
    그래서 그거의 해결책으로 module화 해서 exports 객체를 사용하는건 알겠다고
    근데 왜 exports 객체를 사용하는 형태를 갖게 된거지?
    c언어의 include나 java의 import보다 편한 부분이 있는거겠지? 그게 뭘까
    외장모듈이 존재하는거와 관련이 있을까? 다른 모듈을 로드하는데 더 편리한 부분이 있어서? 사용하기에?






https://helloworldjavascript.net/

















